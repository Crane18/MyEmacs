;; -*- mode: emacs-lisp; coding: utf-8-unix -*-
;; Minibuffer history file, automatically generated by `savehist'.

(setq savehist-minibuffer-history-variables '(minibuffer-history-search-history diminish-history-names diminish-history-symbols buffer-name-history ido-buffer-history gud-gdb-history compile-history dired-shell-command-history shell-command-history query-replace-history file-name-history minibuffer-history gud-jdb-history ido-file-history extended-command-history))
(setq diminish-history-names '("V"))
(setq diminish-history-symbols '("rainbow-delimiters-mode"))
(setq buffer-name-history '("core.clj" "*cider-repl command-line-args*" "core.clj" "*cider-repl command-line-args*" "core_test.clj" "*cider-repl command-line-args*" "core_test.clj" "*eshell*" "linuxC.sh" "init-emacs-w3m.el" "network.sh" "policykit.sh" "crane" "node" "justtest.cpp" "time.c"))
(setq ido-buffer-history '("core.clj" "*cider-repl command-line-args*" "core.clj" "*cider-repl command-line-args*" "core_test.clj" #("core.clj" 0 8 (face ido-virtual)) "*cider-repl command-line-args*" "core_test.clj" nil "linuxC.sh" "init-emacs-w3m.el" "network.sh" "policykit.sh" "justtest.cpp" "time.c"))
(setq gud-gdb-history '("gdb time" "gdb FirstJava"))
(setq compile-history '("gcc test.c -o test" "gcc time.c -o time" "gcc -o time.c time" "gcc -o time.c time.out" "javac FirstJava.java" "javac"))
(setq dired-shell-command-history '("dired" "open"))
(setq shell-command-history '("cd codes" "cd ~/home"))
(setq query-replace-history '("pro" "profiles" "GetStaticMethodID" "GetMethodID" "renhe940318" "username" "altered" "changed"))
(setq file-name-history '("/home/crane/clojure_in_emacs.txt" "~/command-line-args/src/command_line_args/core.clj" "~/.m2/repository/org/clojure/clojure/1.6.0/clojure-1.6.0.jar" "/home/crane/command-line-args/src/command_line_args/core.clj" "/home/crane/command-line-args/test/command_line_args/core_test.clj" "~/command-line-args/project.clj" "/home/crane/command-line-args/project.clj" "/home/crane/command-line-args/src/command_line_args/core.clj" "/home/crane/command-line-args/test/command_line_args/core_test.clj" "/home/crane/command-line-args/project.clj" "/media/crane/新加卷/workspace/OrderSystem/src/hust/groupwork/ordersys/frame/DishesManagerFrame.java" "/home/crane/command-line-args/test/command_line_args/core_test.clj" "/home/crane/command-line-args/src/command_line_args/core.clj" "/home/crane/command-line-args/project.clj" "~/.android/androidtool.cfg" "/home/crane/.android/androidtool.cfg" "/home/crane/.bashrc" "~/.bashrc" "/home/crane/.emacs-places" "~/.emacs.d/elpa/projectile-0.10.0/projectile-autoloads.el" "/home/crane/bin/lein" "~/.emacs.d/elpa/cider-0.5.0/cider-autoloads.el" "~/.emacs.d/elpa/pkg-info-0.5/pkg-info-autoloads.el" "~/.emacs.d/elpa/epl-0.7/epl-autoloads.el" "~/.emacs.d/elpa/clojure-mode-2.1.1/clojure-mode-autoloads.el" "/home/crane/codes/javacodes/Generics.java" "~/AndroidStudio/android-studio/bin/studio.sh" "/home/crane/codes/c-code/AnimalManager.cpp" "/home/crane/codes/c-code/VirtualBase.cpp" "/home/crane/codes/c-code/.#VirtualBase.cpp" "/home/crane/codes/c-code/staticlist.cpp" "/home/crane/codes/c-code/mypoint/tpoint1.cpp" "/home/crane/codes/c-code/mypoint/tpoint1.h" "/home/crane/codes/c-code/pointer.cpp" "~/codes/c-code/pointer.cpp" "/home/crane/codes/c-code/hash.c" "/home/crane/codes/c-code/TestOne.cpp" "/home/crane/codes/c-code/justtest.cpp" "/home/crane/codes/c-code/consttest.cpp" "/tmp/.fr-5aN0Ph/aliedit.sh" "/home/crane/codes/c-code/MyClass.cpp" "~/.emacs.d/init.el" "/home/crane/.emacs.d/init.el" "/home/crane/codes/javacodes/HeapOOM.java" "~/workspace/ApiDemos/README.txt" "/home/crane/android-dev-tools/app/kelvin/src/sg/nus/KelvinSungEX2/MainActivity.java" "/home/crane/android-dev-tools/app/KelvinSungEX2/AndroidManifest.xml" "/home/crane/android-dev-tools/app/kelvin/res/layout/select_image_fragment.xml" "/home/crane/android-dev-tools/app/Kelvin.apk" "/etc/hosts" \.\.\.))
(setq minibuffer-history '("/home/crane/command-line-args/src/command_line_args/" "command" "/home/crane/command-line-args/proje" "/home/crane/.android/androidtool.c" "/home/crane/.bashrc" "projectile" "cider" "clo" "version" "14" "/home/crane/codes/c-code/mypoint" "/home/crane/codes/c-code/point" "/home/crane/.emacs.d/init.el" "/home/crane/codes/javacodes/annotations" "/home/crane/Native" "/etc/apt/source.list" "/home/crane/codes/gradle" "141" "/etc/.bash" "c-outline-level" "/home/crane/codes/javacodes/Contructor" \.\.\.))
(setq gud-jdb-history '("javac Hello.java" "jdb FirstJava" "jdb FirstJava.java"))
(setq ido-file-history '("clojure_in_emacs.txt" "core.clj" "core_test.clj" "project.clj" "core.clj" "core_test.clj" "project.clj" "DishesManagerFrame.java" "core_test.clj" "core.clj" "project.clj" "androidtool.cfg" ".bashrc" "elpa/" ".emacs-places" "lein" "Generics.java" nil "AnimalManager.cpp" "VirtualBase.cpp" ".#VirtualBase.cpp" "staticlist.cpp" "tpoint1.cpp" "tpoint1.h" "pointer.cpp" "hash.c" "TestOne.cpp" "justtest.cpp" "consttest.cpp" "MyClass.cpp" "init.el" "HeapOOM.java" "MainActivity.java" "AndroidManifest.xml" "select_image_fragment.xml" "Kelvin.apk" "hosts" "FirstJava.html" \.\.\.))
(setq extended-command-history '("eshell" "cider-quit" "imenu" "cider-jack-in" "load-file" "eshell" "package-install" "package-refresh-contents" "version" "package-list-packages-no-fetch" "goto-line" "mkdir" "mouse-secondary-save-then-kill" "shell" "save-buffers-kill-terminal" "make-directory" "replace-string" "Buffer-menu-this-window" \.\.\.))
(setq search-ring 'nil)
(setq regexp-search-ring 'nil)
(setq kill-ring '("Basics
The first thing you should do without question, is to go through the built-in Emacs tutorial. To do this press C-h t or hold down Control and press h and then press t by itself.

With that in mind, these are the basic keystrokes you're going to be using most often:

File/buffer/window commands
C-x C-f     Find file
C-x C-s     Save buffer
C-x s       Save file (like save-as)
C-x b       Switch buffer
C-x k       Kill buffer
C-x 1       Delete other windows
C-x 0       Delete current window
C-x 2       Split window horizontally
C-x 3       Split window vertically

Movement commands
C-a         Beginning of line
C-e         End of line
C-n         Next line (down)
C-p         Previous line (up)
C-b         Back (left)
C-f         Forward (right)
M-f         Forward a word
M-b         Back a word
C-v         Forward a page
M-v         Back a page

Edit commands
C-d         Kill character
M-d         Kill word
M-delete    Kill word backwards

Misc commands
C-s         Regex search forwards
C-r         Regex search backwards
M-%         Query replace
I should also mention the help commands:

C-h t     Tutorial (goes over the basics)
C-h b     Describe all current key bindings
C-h m     Describe the current mode
C-h a     Apropos - search the help for a term
C-h k     Describe key
I recommend going through the tutorial at least once as it will give you a good understanding of the navigation and movement commands. Another useful command you will use a lot is M-x which allows you to run any command. And there are a LOT. Apropos is very useful for searching for something C-h a.

So after doing the tutorial (you did do that, RIGHT? O_O) you can move around, open files, save files, etc., and are generally comfortable at the basics. There is an almost infinite amount of things to learn about Emacs, but those basics will get you a long way.

Creating a project
Let's go through the process of creating a small sample clojure project and illustrate how Emacs helps makes us champions in the land of lisp.

The project we will be building is a trivially simple command line parser that will take the argument pairs given to it and turn them into a map of key-value pairs. The functionality is irrelevant and not particularly useful. It serves purely to illustrate the development flow.

If you don't have Leiningen yet, get it installed and then use it to create a new project:

$ lein new command-line-args
$ cd command-line-args
Take a look at the project structure:

+ doc
  - intro.md
- project.clj
- README.md
+ src
  + command_line_args
    - core.clj
+ test
  + command_line_args
    - core_test.clj
Should be fairly self-explanatory, though Leiningen's built-in tutorial (available via lein help tutorial) provides a detailed explanation of the project structure.

Before we continue we have to make our project play with CIDER, which requires a bit of one time setup. Open the project.clj file and add the cider-nrepl plugin there. The file will initially look like this (more or less):

(defproject command-line-args \"0.1.0-SNAPSHOT\"
  :description \"FIXME: write description\"
  :url \"http://example.com/FIXME\"
  :license {:name \"Eclipse Public License\"
            :url \"http://www.eclipse.org/legal/epl-v10.html\"}
  :dependencies [[org.clojure/clojure \"1.6.0\"]])
You need to get to this (keep in mind that by the time you read this cider-nrepl will likely have a newer version):

(defproject command-line-args \"0.1.0-SNAPSHOT\"
  :description \"FIXME: write description\"
  :url \"http://example.com/FIXME\"
  :license {:name \"Eclipse Public License\"
            :url \"http://www.eclipse.org/legal/epl-v10.html\"}
  :dependencies [[org.clojure/clojure \"1.6.0\"]]
  :profiles {:dev {:plugins [[cider/cider-nrepl \"0.7.0\"]]}})
Let's start up a live REPL session.

M-x cider-jack-in
This should open up a new window looking at our *cider-repl* buffer.

First thing to do is add a simple test (in fact the only test we will be adding because by default, we get it right first time). Open the core_test.clj file inside of the test folder. Replace the test that is there with the following:

(deftest pairs-of-values
   (let [args [\"--server\" \"localhost\"
               \"--port\" \"8080\"
               \"--environment\" \"production\"]]
      (is (= {:server \"localhost\"
              :port \"8080\"
              :environment \"production\"}
             (parse-args args)))))
We are simply assigning a list of arguments as they would arrive from the command line to a local called args, and asserting that the return value from a function called parse-args is equal to those command line args turned into a simple map.

Compile the file with C-c C-k. We should get an error message at the bottom of the emacs window complaining that clojure can't find parse-args. Let's try to fix the exception by opening core.clj (C-x C-f) and adding the following definition:

(defn parse-args [args]
  {})
Compile this with C-c C-k, save it (C-x C-s), switch back to the test buffer (C-x b ENTER) and try compiling again (C-c C-k). This time it will succeed, so try running the tests with C-c , and you should get a test report buffer showing some failure information. To check what the problem was, we can move our cursor over the red bar and press C-c '. This shows the problem with the assertion in the mini-buffer:

(not (= {:server \"localhost\",
         :port \"8080\",
         :environment \"production\"}
        {}))
Anyway, our map was empty as expected. Let's fix that:

(defn parse-args [args]
  (apply hash-map args))
Running our tests again we now get another error:

(not (= {:server \"localhost\",
         :port \"8080\",
         :environment \"production\"}
        {\"--port\" \"8080\",
         \"--server\" \"localhost\",
         \"--environment\" \"production\"}))
Whoops, our keys are just strings with the dashes still in place. We need to strip those off and turn them into keywords:

(defn parse-args [args]
  (into {} (map (fn [[k v]] [(keyword (.replace k \"--\" \"\")) v])
                (partition 2 args))))
And re-running the tests in the test buffer we are all happy. If we had multiple test files we can run them all from the CLI using:

$ lein test
Re-running all the tests from Leiningen can be a good sanity check before you wrap up work on a feature or branch since there are some cases where developing from a REPL can give misleading results. For instance, if you delete a function definition but still call it from other functions, you won't notice until your process is restarted.

So that is an extremely simple example of a workflow using Emacs with clojure-mode and cider-test.

Using the REPL
One thing we haven't looked at is how useful having an open running REPL in Emacs can be for development. If you still have your project open, split the window (C-x 2 (horizontal) or C-x 3 (vertical)) in two so you have the core.clj and *cider-repl* buffers open. Let's say you are editing the core.clj and you want to play around with the functions as you define them. Looking at parse-args you have decided you want to pull out the anonymous function to be a named function keywordize.

First load and compile the buffer into the REPL process with C-c C-k. Change the namespace of the REPL buffer to the one of the file you're in with C-c M-n. Now switch to the REPL window with C-x o.

You now have access to the functions in this namespace that were defined when you compiled the file. Try it:

command-line-args.core> (parse-args '(\"key\" \"value\"))
{:key \"value\"}
Let's go ahead and create our new function in core.clj:

(defn keywordize [kvp]
  (let [[k v] kvp]
    [(keyword (.replace k \"--\" \"\")) v]))

(defn parse-args [args]
  (into {} (map keywordize (partition 2 args))))
Now we have a couple of options, we could re-compile the whole file again (C-c C-k) or we could evaluate each function on its own by going to the end of the s-exp and using C-x C-e which sends the s-exp to the running REPL. Now switching back to the core.clj namespace (C-c M-n) and switching back to the REPL buffer we can try out our keywordize function:

command-line-args.core> (keywordize [\"--oh\" \"hai\"])
[:oh \"hai\"]
If your REPL is starting to get cluttered you can C-c M-o to clear it which is nice. The ability to continually change the code and play around with it is one of the things that makes Emacs and a lisp a great combination for development.

If you find yourself wanting to repeat a command you just typed at the REPL, you can use M-p scroll back through history and M-n to go forwards. Also, all of the Emacs editing commands are available in the REPL, which is great.

A handy clojure function to use in the REPL is clojure.repl/doc which gives you the docstring for a given function:

command-line-args.core> (use 'clojure.repl)
nil
command-line-args.core> (doc println)
-------------------------
clojure.core/println
([& more])
  Same as print followed by (newline)
nil
However there is a shortcut C-c C-d d when your cursor is over a function name. This will show the Clojure (or Javadoc) doc in a new window. If instead you want to jump to the source of the function you can use M-., which is awesome. This works on your own functions as well as those which come from third-party libraries. Use M-, to pop the stack and return to where you were. For all the definitions in a single file you can use M-x imenu to list them and jump to one.

When you are finished with the REPL (or if for some reason it has gotten into a bad state), you can simply kill the *cider-repl* buffer by typing M-x cider-quit and re-run cider-jack-in to start another." "(keywordize [\"--oh\" \"hai\"])" "(defn keywordize [kvp]
  (let [[k v] kvp]
    [(keyword (.replace k \"--\" \"\")) v]))

(defn parse-args [args]
  (into {} (map keywordize (partition 2 args))))" "(defn parse-args [args]
  (into {} (map (fn [[k v]] [(keyword (.replace k \"--\" \"\")) v])
                (partition 2 args))))" "(parse-args '(\"key\" \"value\"))" #("(defproject command-line-args \"0.1.0-SNAPSHOT\"
  :description \"FIXME: write description\"
  :url \"http://example.com/FIXME\"
  :license {:name \"Eclipse Public License\"
            :url \"http://www.eclipse.org/legal/epl-v10.html\"}
  :dependencies [[org.clojure/clojure \"1.6.0\"]]
  :profiles {:dev {:plugins [[cider/cider-nrepl \"0.7.0\"]]}})
" 0 1 (fontified t) 1 11 (fontified t face font-lock-keyword-face) 11 12 (fontified t) 12 29 (fontified t face font-lock-function-name-face) 29 30 (fontified t) 30 46 (fontified t face font-lock-string-face) 46 49 (fontified t) 49 61 (fontified t face font-lock-constant-face) 61 62 (fontified t) 62 88 (fontified t face font-lock-string-face) 88 91 (fontified t) 91 95 (fontified t face font-lock-constant-face) 95 96 (fontified t) 96 122 (fontified t face font-lock-string-face) 122 125 (fontified t) 125 133 (fontified t face font-lock-constant-face) 133 135 (fontified t) 135 140 (fontified t face font-lock-constant-face) 140 141 (fontified t) 141 165 (fontified t face font-lock-string-face) 165 178 (fontified t) 178 182 (fontified t face font-lock-constant-face) 182 183 (fontified t) 183 226 (fontified t face font-lock-string-face) 226 230 (fontified t) 230 243 (fontified t face font-lock-constant-face) 243 266 (fontified t) 266 273 (fontified t face font-lock-string-face) 273 278 (fontified t) 278 287 (fontified t face font-lock-constant-face) 287 289 (fontified t) 289 293 (fontified t face font-lock-constant-face) 293 295 (fontified t) 295 303 (fontified t face font-lock-constant-face) 303 324 (fontified t) 324 331 (fontified t face font-lock-string-face) 331 337 (fontified t))))
